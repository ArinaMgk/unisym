// ASCII CPP TAB4 CRLF
// Attribute: <ArnCovenant> <Env> <bin^%> <CPU()> [Allocation]
// LastCheck: <date>
// AllAuthor: @dosconio
// ModuTitle: ...
// Copyright: ...

#ifndef _INC_DEVICE_GPIO_X
#define _INC_DEVICE_GPIO_X

#include "../../c/alice.h"
#include "../../c/binary.h"
#include "../reference"

#ifdef _MCU_STM32F103VE

#if !(_typedest_len==4 && _typeaddr_len==4)
#error "! You may need add optional macro `_MCU_STM32F103VE`"
#endif

// 00000000 maybe a valid address of someone
// Design of Harunono Style
// 202404112300: I tried use std::bind(), C++11 in ARMCC-v6, but it make MCU did not work! So do not use Property STYLE!

namespace uni {
	namespace GPIOMode {
		enum Mode {
			OUT_PushPull     = 0 << 2, 
			OUT_OpenDrain    = 1 << 2,
			OUT_AF_PushPull  = 2 << 2,
			OUT_AF_OpenDrain = 3 << 2,
			IN_Analog   = 1 + (0 << 2),
			IN_Floating = 1 + (1 << 2), // default state
			IN_PullDown = 1 + (2 << 2),
			IN_KEPT     = 1 + (3 << 2)
		};
	}
	namespace GPIOSpeed {
		enum Speed {
			Atmost_Input = 0,
			Atmost_10MHz = 1,
			Atmost_2MHz  = 2,
			Atmost_50MHz = 3,
		};
	    
	}

	class GeneralPurposeInputOutputPin;
	class GeneralPurposeInputOutputPort;
	//
	class GeneralPurposeInputOutputPin {
		GeneralPurposeInputOutputPort* parent;
		uint32 bitposi;
	public:
		GeneralPurposeInputOutputPin(GeneralPurposeInputOutputPort* parent = 0, uint32 bitposi = 0) : parent(parent), bitposi(bitposi) {}
		GeneralPurposeInputOutputPin& operator=(bool val);
		void setMode(GPIOMode::Mode mod, GPIOSpeed::Speed spd = GPIOSpeed::Atmost_2MHz);
	};
	
	class GeneralPurposeInputOutputPort {
		GeneralPurposeInputOutputPin OutpdPins[8];
		GeneralPurposeInputOutputPin ERR;
		uint32 EnablPosi;// of ClockPort
	public:
		Reference ClockPort;
		Reference OutpdPort;// Output Data Register
		Reference CnrglPort;// Control Register Low
		GeneralPurposeInputOutputPort(uint32 CLK, uint32 ODR, uint32 CRL, uint32 Enap = 0) :
			EnablPosi(Enap), // (RCC_APB2ENR)
			ClockPort(CLK),
			OutpdPort(ODR),
			CnrglPort(CRL)
		{
			for0 (i, numsof(OutpdPins))
				OutpdPins[i] = GeneralPurposeInputOutputPin(this, i);
		}
		void enClock(bool enable = true) {
			BitSet(ClockPort, EnablPosi);
		}
		GeneralPurposeInputOutputPin& operator[](uint8 pinid) {
			return pinid < numsof(OutpdPins) ? OutpdPins[pinid] : ERR;
		}
	};
	extern GeneralPurposeInputOutputPort GPIOA;
	extern GeneralPurposeInputOutputPort GPIOB;
	extern GeneralPurposeInputOutputPort GPIOC;
	extern GeneralPurposeInputOutputPort GPIOD;
	extern GeneralPurposeInputOutputPort GPIOE;
	



	class GeneralPurposeInputOutput {
	public:
		
		GeneralPurposeInputOutputPort ERR;
		GeneralPurposeInputOutput() : ERR(~0, ~0, ~0) {

		}
		GeneralPurposeInputOutputPort& operator[](char portid) {
			GeneralPurposeInputOutputPort* GPIO_List[] = {
				&GPIOA, &GPIOB, &GPIOC, &GPIOD, &GPIOE
			};
			switch (portid) {
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
				return *(GPIO_List[portid - 'A']);// break;
			default:
				return ERR;// break;
			}
		}
	};
	extern GeneralPurposeInputOutput GPIO;

	typedef GeneralPurposeInputOutputPin GPIO_Pin;
	typedef GeneralPurposeInputOutputPort GPIO_Port;
}



#endif


#endif // !_INC_DEVICE_GPIO_X
