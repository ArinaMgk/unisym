
\subsection{Bridge between Machine-code and Advanced-language}

The concept of `state machine' is widely accepted, for it describing the effect of the instructions, which can help us to get numeric register-effects and other side-effects.

For example, the rules of conversion from function calling, entering(including allocating stack and others), leaving and evaluation to assembly implementation should be specific.

More to see
\begin{itemize}
	\item \refer{Calling}
\end{itemize}

\subsection{Syntax, Semantics and Statement} % Grammar
\subimport{CLV/Program}{Statement}

\subsection{Scope and Linkage}

\subsection{Identifier and Token Parsing}
\subimport{CLV/Program}{Identifier}

\subsection{Keyword and Operator Parsing}
\subimport{CLV/Program}{Keyword}
\input{CLV/Program/Operator.tex}

\subsection{Preprocessing and Parsing}
\subimport{CLV/Program}{Parsing}

\subsection{Procedure, Function and Method}
\labex{Function}
\subimport{CLV/Program}{Function}

\subsection{Standard, Style and Arinae Covenant}
\subimport{CLV/Program}{Standard}

\subsection{Target and Output Format}
\input{CLV/Program/Target}


\subsection{Assertion and Exception}

\subsection{Special Notion and Adaptation}

\subsubsection{Parallel and Multi-process}

